"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const AccessToken_1 = require("./AccessToken");
const livekit_recording_1 = require("./proto/livekit_recording");
const TwirpRPC_1 = require("./TwirpRPC");
const svc = 'RecordingService';
/**
 * Client to access Recording APIs
 */
class RecordingServiceClient {
    /**
     * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
     * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
     * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
     */
    constructor(host, apiKey, secret) {
        this.rpc = new TwirpRPC_1.TwirpRpc(host, TwirpRPC_1.livekitPackage);
        this.apiKey = apiKey;
        this.secret = secret;
    }
    /**
     * @param input input url or recording template
     * @param output output filepath or RtmpOutput
     * @param options recording options
     */
    startRecording(input, output, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let url;
            let template;
            if (typeof input === 'string') {
                url = input;
            }
            else {
                template = input;
            }
            let rtmp;
            let filepath;
            if (typeof output === 'string') {
                filepath = output;
            }
            else {
                rtmp = output;
            }
            const req = livekit_recording_1.StartRecordingRequest.toJSON({
                url, template, rtmp, filepath, options,
            });
            const data = yield this.rpc.request(svc, 'StartRecording', req, this.authHeader({ roomRecord: true }));
            return livekit_recording_1.StartRecordingResponse.fromJSON(data).recordingId;
        });
    }
    addOutput(recordingId, rtmpUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = livekit_recording_1.AddOutputRequest.toJSON({ recordingId, rtmpUrl });
            yield this.rpc.request(svc, 'AddOutput', req, this.authHeader({ roomRecord: true }));
        });
    }
    removeOutput(recordingId, rtmpUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = livekit_recording_1.RemoveOutputRequest.toJSON({ recordingId, rtmpUrl });
            yield this.rpc.request(svc, 'RemoveOutput', req, this.authHeader({ roomRecord: true }));
        });
    }
    endRecording(recordingId) {
        return __awaiter(this, void 0, void 0, function* () {
            const req = livekit_recording_1.EndRecordingRequest.toJSON({ recordingId });
            yield this.rpc.request(svc, 'EndRecording', req, this.authHeader({ roomRecord: true }));
        });
    }
    authHeader(grant) {
        const at = new AccessToken_1.AccessToken(this.apiKey, this.secret, { ttl: '10m' });
        at.addGrant(grant);
        return {
            Authorization: `Bearer ${at.toJwt()}`,
        };
    }
}
exports.default = RecordingServiceClient;
//# sourceMappingURL=RecordingServiceClient.js.map