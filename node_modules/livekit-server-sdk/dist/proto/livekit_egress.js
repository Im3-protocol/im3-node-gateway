"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileInfo = exports.StreamInfo = exports.StreamInfoList = exports.EgressInfo = exports.StopEgressRequest = exports.ListEgressResponse = exports.ListEgressRequest = exports.UpdateStreamRequest = exports.UpdateLayoutRequest = exports.EncodingOptions = exports.StreamOutput = exports.AzureBlobUpload = exports.GCPUpload = exports.S3Upload = exports.EncodedFileOutput = exports.TrackEgressRequest = exports.TrackCompositeEgressRequest = exports.WebCompositeEgressRequest = exports.egressStatusToJSON = exports.egressStatusFromJSON = exports.EgressStatus = exports.encodingOptionsPresetToJSON = exports.encodingOptionsPresetFromJSON = exports.EncodingOptionsPreset = exports.videoCodecToJSON = exports.videoCodecFromJSON = exports.VideoCodec = exports.audioCodecToJSON = exports.audioCodecFromJSON = exports.AudioCodec = exports.streamProtocolToJSON = exports.streamProtocolFromJSON = exports.StreamProtocol = exports.encodedFileTypeToJSON = exports.encodedFileTypeFromJSON = exports.EncodedFileType = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const _m0 = __importStar(require("protobufjs/minimal"));
exports.protobufPackage = "livekit";
var EncodedFileType;
(function (EncodedFileType) {
    EncodedFileType[EncodedFileType["MP4"] = 0] = "MP4";
    /** OGG - WEBM = 2; coming soon */
    EncodedFileType[EncodedFileType["OGG"] = 1] = "OGG";
    EncodedFileType[EncodedFileType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(EncodedFileType = exports.EncodedFileType || (exports.EncodedFileType = {}));
function encodedFileTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "MP4":
            return EncodedFileType.MP4;
        case 1:
        case "OGG":
            return EncodedFileType.OGG;
        case -1:
        case "UNRECOGNIZED":
        default:
            return EncodedFileType.UNRECOGNIZED;
    }
}
exports.encodedFileTypeFromJSON = encodedFileTypeFromJSON;
function encodedFileTypeToJSON(object) {
    switch (object) {
        case EncodedFileType.MP4:
            return "MP4";
        case EncodedFileType.OGG:
            return "OGG";
        default:
            return "UNKNOWN";
    }
}
exports.encodedFileTypeToJSON = encodedFileTypeToJSON;
var StreamProtocol;
(function (StreamProtocol) {
    /** RTMP - SRT  = 1; coming soon */
    StreamProtocol[StreamProtocol["RTMP"] = 0] = "RTMP";
    StreamProtocol[StreamProtocol["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(StreamProtocol = exports.StreamProtocol || (exports.StreamProtocol = {}));
function streamProtocolFromJSON(object) {
    switch (object) {
        case 0:
        case "RTMP":
            return StreamProtocol.RTMP;
        case -1:
        case "UNRECOGNIZED":
        default:
            return StreamProtocol.UNRECOGNIZED;
    }
}
exports.streamProtocolFromJSON = streamProtocolFromJSON;
function streamProtocolToJSON(object) {
    switch (object) {
        case StreamProtocol.RTMP:
            return "RTMP";
        default:
            return "UNKNOWN";
    }
}
exports.streamProtocolToJSON = streamProtocolToJSON;
var AudioCodec;
(function (AudioCodec) {
    AudioCodec[AudioCodec["DEFAULT_AC"] = 0] = "DEFAULT_AC";
    AudioCodec[AudioCodec["OPUS"] = 1] = "OPUS";
    AudioCodec[AudioCodec["AAC"] = 2] = "AAC";
    AudioCodec[AudioCodec["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AudioCodec = exports.AudioCodec || (exports.AudioCodec = {}));
function audioCodecFromJSON(object) {
    switch (object) {
        case 0:
        case "DEFAULT_AC":
            return AudioCodec.DEFAULT_AC;
        case 1:
        case "OPUS":
            return AudioCodec.OPUS;
        case 2:
        case "AAC":
            return AudioCodec.AAC;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AudioCodec.UNRECOGNIZED;
    }
}
exports.audioCodecFromJSON = audioCodecFromJSON;
function audioCodecToJSON(object) {
    switch (object) {
        case AudioCodec.DEFAULT_AC:
            return "DEFAULT_AC";
        case AudioCodec.OPUS:
            return "OPUS";
        case AudioCodec.AAC:
            return "AAC";
        default:
            return "UNKNOWN";
    }
}
exports.audioCodecToJSON = audioCodecToJSON;
var VideoCodec;
(function (VideoCodec) {
    VideoCodec[VideoCodec["DEFAULT_VC"] = 0] = "DEFAULT_VC";
    VideoCodec[VideoCodec["H264_BASELINE"] = 1] = "H264_BASELINE";
    VideoCodec[VideoCodec["H264_MAIN"] = 2] = "H264_MAIN";
    /**
     * H264_HIGH - HEVC = 4; coming soon
     *  VP8 = 5;  coming soon
     *  VP9 = 6;  coming soon
     */
    VideoCodec[VideoCodec["H264_HIGH"] = 3] = "H264_HIGH";
    VideoCodec[VideoCodec["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(VideoCodec = exports.VideoCodec || (exports.VideoCodec = {}));
function videoCodecFromJSON(object) {
    switch (object) {
        case 0:
        case "DEFAULT_VC":
            return VideoCodec.DEFAULT_VC;
        case 1:
        case "H264_BASELINE":
            return VideoCodec.H264_BASELINE;
        case 2:
        case "H264_MAIN":
            return VideoCodec.H264_MAIN;
        case 3:
        case "H264_HIGH":
            return VideoCodec.H264_HIGH;
        case -1:
        case "UNRECOGNIZED":
        default:
            return VideoCodec.UNRECOGNIZED;
    }
}
exports.videoCodecFromJSON = videoCodecFromJSON;
function videoCodecToJSON(object) {
    switch (object) {
        case VideoCodec.DEFAULT_VC:
            return "DEFAULT_VC";
        case VideoCodec.H264_BASELINE:
            return "H264_BASELINE";
        case VideoCodec.H264_MAIN:
            return "H264_MAIN";
        case VideoCodec.H264_HIGH:
            return "H264_HIGH";
        default:
            return "UNKNOWN";
    }
}
exports.videoCodecToJSON = videoCodecToJSON;
var EncodingOptionsPreset;
(function (EncodingOptionsPreset) {
    /** H264_720P_30 - 720p, 30fps, 3000kpbs, H.264_MAIN / OPUS */
    EncodingOptionsPreset[EncodingOptionsPreset["H264_720P_30"] = 0] = "H264_720P_30";
    /** H264_720P_60 - 720p, 60fps, 4500kbps, H.264_MAIN / OPUS */
    EncodingOptionsPreset[EncodingOptionsPreset["H264_720P_60"] = 1] = "H264_720P_60";
    /** H264_1080P_30 - 1080p, 30fps, 4500kbps, H.264_MAIN / OPUS */
    EncodingOptionsPreset[EncodingOptionsPreset["H264_1080P_30"] = 2] = "H264_1080P_30";
    /** H264_1080P_60 - 1080p, 60fps, 6000kbps, H.264_MAIN / OPUS */
    EncodingOptionsPreset[EncodingOptionsPreset["H264_1080P_60"] = 3] = "H264_1080P_60";
    EncodingOptionsPreset[EncodingOptionsPreset["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(EncodingOptionsPreset = exports.EncodingOptionsPreset || (exports.EncodingOptionsPreset = {}));
function encodingOptionsPresetFromJSON(object) {
    switch (object) {
        case 0:
        case "H264_720P_30":
            return EncodingOptionsPreset.H264_720P_30;
        case 1:
        case "H264_720P_60":
            return EncodingOptionsPreset.H264_720P_60;
        case 2:
        case "H264_1080P_30":
            return EncodingOptionsPreset.H264_1080P_30;
        case 3:
        case "H264_1080P_60":
            return EncodingOptionsPreset.H264_1080P_60;
        case -1:
        case "UNRECOGNIZED":
        default:
            return EncodingOptionsPreset.UNRECOGNIZED;
    }
}
exports.encodingOptionsPresetFromJSON = encodingOptionsPresetFromJSON;
function encodingOptionsPresetToJSON(object) {
    switch (object) {
        case EncodingOptionsPreset.H264_720P_30:
            return "H264_720P_30";
        case EncodingOptionsPreset.H264_720P_60:
            return "H264_720P_60";
        case EncodingOptionsPreset.H264_1080P_30:
            return "H264_1080P_30";
        case EncodingOptionsPreset.H264_1080P_60:
            return "H264_1080P_60";
        default:
            return "UNKNOWN";
    }
}
exports.encodingOptionsPresetToJSON = encodingOptionsPresetToJSON;
var EgressStatus;
(function (EgressStatus) {
    EgressStatus[EgressStatus["EGRESS_STARTING"] = 0] = "EGRESS_STARTING";
    EgressStatus[EgressStatus["EGRESS_ACTIVE"] = 1] = "EGRESS_ACTIVE";
    EgressStatus[EgressStatus["EGRESS_ENDING"] = 2] = "EGRESS_ENDING";
    EgressStatus[EgressStatus["EGRESS_COMPLETE"] = 3] = "EGRESS_COMPLETE";
    EgressStatus[EgressStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(EgressStatus = exports.EgressStatus || (exports.EgressStatus = {}));
function egressStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "EGRESS_STARTING":
            return EgressStatus.EGRESS_STARTING;
        case 1:
        case "EGRESS_ACTIVE":
            return EgressStatus.EGRESS_ACTIVE;
        case 2:
        case "EGRESS_ENDING":
            return EgressStatus.EGRESS_ENDING;
        case 3:
        case "EGRESS_COMPLETE":
            return EgressStatus.EGRESS_COMPLETE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return EgressStatus.UNRECOGNIZED;
    }
}
exports.egressStatusFromJSON = egressStatusFromJSON;
function egressStatusToJSON(object) {
    switch (object) {
        case EgressStatus.EGRESS_STARTING:
            return "EGRESS_STARTING";
        case EgressStatus.EGRESS_ACTIVE:
            return "EGRESS_ACTIVE";
        case EgressStatus.EGRESS_ENDING:
            return "EGRESS_ENDING";
        case EgressStatus.EGRESS_COMPLETE:
            return "EGRESS_COMPLETE";
        default:
            return "UNKNOWN";
    }
}
exports.egressStatusToJSON = egressStatusToJSON;
function createBaseWebCompositeEgressRequest() {
    return {
        roomName: "",
        layout: "",
        audioOnly: false,
        videoOnly: false,
        customBaseUrl: "",
        file: undefined,
        stream: undefined,
        preset: undefined,
        advanced: undefined,
    };
}
exports.WebCompositeEgressRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.roomName !== "") {
            writer.uint32(10).string(message.roomName);
        }
        if (message.layout !== "") {
            writer.uint32(18).string(message.layout);
        }
        if (message.audioOnly === true) {
            writer.uint32(24).bool(message.audioOnly);
        }
        if (message.videoOnly === true) {
            writer.uint32(32).bool(message.videoOnly);
        }
        if (message.customBaseUrl !== "") {
            writer.uint32(42).string(message.customBaseUrl);
        }
        if (message.file !== undefined) {
            exports.EncodedFileOutput.encode(message.file, writer.uint32(50).fork()).ldelim();
        }
        if (message.stream !== undefined) {
            exports.StreamOutput.encode(message.stream, writer.uint32(58).fork()).ldelim();
        }
        if (message.preset !== undefined) {
            writer.uint32(64).int32(message.preset);
        }
        if (message.advanced !== undefined) {
            exports.EncodingOptions.encode(message.advanced, writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWebCompositeEgressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.roomName = reader.string();
                    break;
                case 2:
                    message.layout = reader.string();
                    break;
                case 3:
                    message.audioOnly = reader.bool();
                    break;
                case 4:
                    message.videoOnly = reader.bool();
                    break;
                case 5:
                    message.customBaseUrl = reader.string();
                    break;
                case 6:
                    message.file = exports.EncodedFileOutput.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.stream = exports.StreamOutput.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.preset = reader.int32();
                    break;
                case 9:
                    message.advanced = exports.EncodingOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            roomName: isSet(object.roomName) ? String(object.roomName) : "",
            layout: isSet(object.layout) ? String(object.layout) : "",
            audioOnly: isSet(object.audioOnly) ? Boolean(object.audioOnly) : false,
            videoOnly: isSet(object.videoOnly) ? Boolean(object.videoOnly) : false,
            customBaseUrl: isSet(object.customBaseUrl)
                ? String(object.customBaseUrl)
                : "",
            file: isSet(object.file)
                ? exports.EncodedFileOutput.fromJSON(object.file)
                : undefined,
            stream: isSet(object.stream)
                ? exports.StreamOutput.fromJSON(object.stream)
                : undefined,
            preset: isSet(object.preset)
                ? encodingOptionsPresetFromJSON(object.preset)
                : undefined,
            advanced: isSet(object.advanced)
                ? exports.EncodingOptions.fromJSON(object.advanced)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.roomName !== undefined && (obj.roomName = message.roomName);
        message.layout !== undefined && (obj.layout = message.layout);
        message.audioOnly !== undefined && (obj.audioOnly = message.audioOnly);
        message.videoOnly !== undefined && (obj.videoOnly = message.videoOnly);
        message.customBaseUrl !== undefined &&
            (obj.customBaseUrl = message.customBaseUrl);
        message.file !== undefined &&
            (obj.file = message.file
                ? exports.EncodedFileOutput.toJSON(message.file)
                : undefined);
        message.stream !== undefined &&
            (obj.stream = message.stream
                ? exports.StreamOutput.toJSON(message.stream)
                : undefined);
        message.preset !== undefined &&
            (obj.preset =
                message.preset !== undefined
                    ? encodingOptionsPresetToJSON(message.preset)
                    : undefined);
        message.advanced !== undefined &&
            (obj.advanced = message.advanced
                ? exports.EncodingOptions.toJSON(message.advanced)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseWebCompositeEgressRequest();
        message.roomName = (_a = object.roomName) !== null && _a !== void 0 ? _a : "";
        message.layout = (_b = object.layout) !== null && _b !== void 0 ? _b : "";
        message.audioOnly = (_c = object.audioOnly) !== null && _c !== void 0 ? _c : false;
        message.videoOnly = (_d = object.videoOnly) !== null && _d !== void 0 ? _d : false;
        message.customBaseUrl = (_e = object.customBaseUrl) !== null && _e !== void 0 ? _e : "";
        message.file =
            object.file !== undefined && object.file !== null
                ? exports.EncodedFileOutput.fromPartial(object.file)
                : undefined;
        message.stream =
            object.stream !== undefined && object.stream !== null
                ? exports.StreamOutput.fromPartial(object.stream)
                : undefined;
        message.preset = (_f = object.preset) !== null && _f !== void 0 ? _f : undefined;
        message.advanced =
            object.advanced !== undefined && object.advanced !== null
                ? exports.EncodingOptions.fromPartial(object.advanced)
                : undefined;
        return message;
    },
};
function createBaseTrackCompositeEgressRequest() {
    return {
        roomName: "",
        audioTrackId: "",
        videoTrackId: "",
        file: undefined,
        stream: undefined,
        preset: undefined,
        advanced: undefined,
    };
}
exports.TrackCompositeEgressRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.roomName !== "") {
            writer.uint32(10).string(message.roomName);
        }
        if (message.audioTrackId !== "") {
            writer.uint32(18).string(message.audioTrackId);
        }
        if (message.videoTrackId !== "") {
            writer.uint32(26).string(message.videoTrackId);
        }
        if (message.file !== undefined) {
            exports.EncodedFileOutput.encode(message.file, writer.uint32(34).fork()).ldelim();
        }
        if (message.stream !== undefined) {
            exports.StreamOutput.encode(message.stream, writer.uint32(42).fork()).ldelim();
        }
        if (message.preset !== undefined) {
            writer.uint32(48).int32(message.preset);
        }
        if (message.advanced !== undefined) {
            exports.EncodingOptions.encode(message.advanced, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTrackCompositeEgressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.roomName = reader.string();
                    break;
                case 2:
                    message.audioTrackId = reader.string();
                    break;
                case 3:
                    message.videoTrackId = reader.string();
                    break;
                case 4:
                    message.file = exports.EncodedFileOutput.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.stream = exports.StreamOutput.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.preset = reader.int32();
                    break;
                case 7:
                    message.advanced = exports.EncodingOptions.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            roomName: isSet(object.roomName) ? String(object.roomName) : "",
            audioTrackId: isSet(object.audioTrackId)
                ? String(object.audioTrackId)
                : "",
            videoTrackId: isSet(object.videoTrackId)
                ? String(object.videoTrackId)
                : "",
            file: isSet(object.file)
                ? exports.EncodedFileOutput.fromJSON(object.file)
                : undefined,
            stream: isSet(object.stream)
                ? exports.StreamOutput.fromJSON(object.stream)
                : undefined,
            preset: isSet(object.preset)
                ? encodingOptionsPresetFromJSON(object.preset)
                : undefined,
            advanced: isSet(object.advanced)
                ? exports.EncodingOptions.fromJSON(object.advanced)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.roomName !== undefined && (obj.roomName = message.roomName);
        message.audioTrackId !== undefined &&
            (obj.audioTrackId = message.audioTrackId);
        message.videoTrackId !== undefined &&
            (obj.videoTrackId = message.videoTrackId);
        message.file !== undefined &&
            (obj.file = message.file
                ? exports.EncodedFileOutput.toJSON(message.file)
                : undefined);
        message.stream !== undefined &&
            (obj.stream = message.stream
                ? exports.StreamOutput.toJSON(message.stream)
                : undefined);
        message.preset !== undefined &&
            (obj.preset =
                message.preset !== undefined
                    ? encodingOptionsPresetToJSON(message.preset)
                    : undefined);
        message.advanced !== undefined &&
            (obj.advanced = message.advanced
                ? exports.EncodingOptions.toJSON(message.advanced)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseTrackCompositeEgressRequest();
        message.roomName = (_a = object.roomName) !== null && _a !== void 0 ? _a : "";
        message.audioTrackId = (_b = object.audioTrackId) !== null && _b !== void 0 ? _b : "";
        message.videoTrackId = (_c = object.videoTrackId) !== null && _c !== void 0 ? _c : "";
        message.file =
            object.file !== undefined && object.file !== null
                ? exports.EncodedFileOutput.fromPartial(object.file)
                : undefined;
        message.stream =
            object.stream !== undefined && object.stream !== null
                ? exports.StreamOutput.fromPartial(object.stream)
                : undefined;
        message.preset = (_d = object.preset) !== null && _d !== void 0 ? _d : undefined;
        message.advanced =
            object.advanced !== undefined && object.advanced !== null
                ? exports.EncodingOptions.fromPartial(object.advanced)
                : undefined;
        return message;
    },
};
function createBaseTrackEgressRequest() {
    return {
        roomName: "",
        trackId: "",
        httpUrl: undefined,
        websocketUrl: undefined,
    };
}
exports.TrackEgressRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.roomName !== "") {
            writer.uint32(10).string(message.roomName);
        }
        if (message.trackId !== "") {
            writer.uint32(18).string(message.trackId);
        }
        if (message.httpUrl !== undefined) {
            writer.uint32(26).string(message.httpUrl);
        }
        if (message.websocketUrl !== undefined) {
            writer.uint32(34).string(message.websocketUrl);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTrackEgressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.roomName = reader.string();
                    break;
                case 2:
                    message.trackId = reader.string();
                    break;
                case 3:
                    message.httpUrl = reader.string();
                    break;
                case 4:
                    message.websocketUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            roomName: isSet(object.roomName) ? String(object.roomName) : "",
            trackId: isSet(object.trackId) ? String(object.trackId) : "",
            httpUrl: isSet(object.httpUrl) ? String(object.httpUrl) : undefined,
            websocketUrl: isSet(object.websocketUrl)
                ? String(object.websocketUrl)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.roomName !== undefined && (obj.roomName = message.roomName);
        message.trackId !== undefined && (obj.trackId = message.trackId);
        message.httpUrl !== undefined && (obj.httpUrl = message.httpUrl);
        message.websocketUrl !== undefined &&
            (obj.websocketUrl = message.websocketUrl);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseTrackEgressRequest();
        message.roomName = (_a = object.roomName) !== null && _a !== void 0 ? _a : "";
        message.trackId = (_b = object.trackId) !== null && _b !== void 0 ? _b : "";
        message.httpUrl = (_c = object.httpUrl) !== null && _c !== void 0 ? _c : undefined;
        message.websocketUrl = (_d = object.websocketUrl) !== null && _d !== void 0 ? _d : undefined;
        return message;
    },
};
function createBaseEncodedFileOutput() {
    return {
        fileType: 0,
        filepath: "",
        s3: undefined,
        gcp: undefined,
        azure: undefined,
    };
}
exports.EncodedFileOutput = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.fileType !== 0) {
            writer.uint32(8).int32(message.fileType);
        }
        if (message.filepath !== "") {
            writer.uint32(18).string(message.filepath);
        }
        if (message.s3 !== undefined) {
            exports.S3Upload.encode(message.s3, writer.uint32(26).fork()).ldelim();
        }
        if (message.gcp !== undefined) {
            exports.GCPUpload.encode(message.gcp, writer.uint32(34).fork()).ldelim();
        }
        if (message.azure !== undefined) {
            exports.AzureBlobUpload.encode(message.azure, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncodedFileOutput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.fileType = reader.int32();
                    break;
                case 2:
                    message.filepath = reader.string();
                    break;
                case 3:
                    message.s3 = exports.S3Upload.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.gcp = exports.GCPUpload.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.azure = exports.AzureBlobUpload.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            fileType: isSet(object.fileType)
                ? encodedFileTypeFromJSON(object.fileType)
                : 0,
            filepath: isSet(object.filepath) ? String(object.filepath) : "",
            s3: isSet(object.s3) ? exports.S3Upload.fromJSON(object.s3) : undefined,
            gcp: isSet(object.gcp) ? exports.GCPUpload.fromJSON(object.gcp) : undefined,
            azure: isSet(object.azure)
                ? exports.AzureBlobUpload.fromJSON(object.azure)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.fileType !== undefined &&
            (obj.fileType = encodedFileTypeToJSON(message.fileType));
        message.filepath !== undefined && (obj.filepath = message.filepath);
        message.s3 !== undefined &&
            (obj.s3 = message.s3 ? exports.S3Upload.toJSON(message.s3) : undefined);
        message.gcp !== undefined &&
            (obj.gcp = message.gcp ? exports.GCPUpload.toJSON(message.gcp) : undefined);
        message.azure !== undefined &&
            (obj.azure = message.azure
                ? exports.AzureBlobUpload.toJSON(message.azure)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseEncodedFileOutput();
        message.fileType = (_a = object.fileType) !== null && _a !== void 0 ? _a : 0;
        message.filepath = (_b = object.filepath) !== null && _b !== void 0 ? _b : "";
        message.s3 =
            object.s3 !== undefined && object.s3 !== null
                ? exports.S3Upload.fromPartial(object.s3)
                : undefined;
        message.gcp =
            object.gcp !== undefined && object.gcp !== null
                ? exports.GCPUpload.fromPartial(object.gcp)
                : undefined;
        message.azure =
            object.azure !== undefined && object.azure !== null
                ? exports.AzureBlobUpload.fromPartial(object.azure)
                : undefined;
        return message;
    },
};
function createBaseS3Upload() {
    return { accessKey: "", secret: "", region: "", endpoint: "", bucket: "" };
}
exports.S3Upload = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.accessKey !== "") {
            writer.uint32(10).string(message.accessKey);
        }
        if (message.secret !== "") {
            writer.uint32(18).string(message.secret);
        }
        if (message.region !== "") {
            writer.uint32(26).string(message.region);
        }
        if (message.endpoint !== "") {
            writer.uint32(34).string(message.endpoint);
        }
        if (message.bucket !== "") {
            writer.uint32(42).string(message.bucket);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseS3Upload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accessKey = reader.string();
                    break;
                case 2:
                    message.secret = reader.string();
                    break;
                case 3:
                    message.region = reader.string();
                    break;
                case 4:
                    message.endpoint = reader.string();
                    break;
                case 5:
                    message.bucket = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            accessKey: isSet(object.accessKey) ? String(object.accessKey) : "",
            secret: isSet(object.secret) ? String(object.secret) : "",
            region: isSet(object.region) ? String(object.region) : "",
            endpoint: isSet(object.endpoint) ? String(object.endpoint) : "",
            bucket: isSet(object.bucket) ? String(object.bucket) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.accessKey !== undefined && (obj.accessKey = message.accessKey);
        message.secret !== undefined && (obj.secret = message.secret);
        message.region !== undefined && (obj.region = message.region);
        message.endpoint !== undefined && (obj.endpoint = message.endpoint);
        message.bucket !== undefined && (obj.bucket = message.bucket);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseS3Upload();
        message.accessKey = (_a = object.accessKey) !== null && _a !== void 0 ? _a : "";
        message.secret = (_b = object.secret) !== null && _b !== void 0 ? _b : "";
        message.region = (_c = object.region) !== null && _c !== void 0 ? _c : "";
        message.endpoint = (_d = object.endpoint) !== null && _d !== void 0 ? _d : "";
        message.bucket = (_e = object.bucket) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseGCPUpload() {
    return { credentials: new Uint8Array(), bucket: "" };
}
exports.GCPUpload = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.credentials.length !== 0) {
            writer.uint32(10).bytes(message.credentials);
        }
        if (message.bucket !== "") {
            writer.uint32(18).string(message.bucket);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGCPUpload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.credentials = reader.bytes();
                    break;
                case 2:
                    message.bucket = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            credentials: isSet(object.credentials)
                ? bytesFromBase64(object.credentials)
                : new Uint8Array(),
            bucket: isSet(object.bucket) ? String(object.bucket) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.credentials !== undefined &&
            (obj.credentials = base64FromBytes(message.credentials !== undefined
                ? message.credentials
                : new Uint8Array()));
        message.bucket !== undefined && (obj.bucket = message.bucket);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseGCPUpload();
        message.credentials = (_a = object.credentials) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.bucket = (_b = object.bucket) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseAzureBlobUpload() {
    return { accountName: "", accountKey: "", containerName: "" };
}
exports.AzureBlobUpload = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.accountName !== "") {
            writer.uint32(10).string(message.accountName);
        }
        if (message.accountKey !== "") {
            writer.uint32(18).string(message.accountKey);
        }
        if (message.containerName !== "") {
            writer.uint32(26).string(message.containerName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAzureBlobUpload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountName = reader.string();
                    break;
                case 2:
                    message.accountKey = reader.string();
                    break;
                case 3:
                    message.containerName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            accountName: isSet(object.accountName) ? String(object.accountName) : "",
            accountKey: isSet(object.accountKey) ? String(object.accountKey) : "",
            containerName: isSet(object.containerName)
                ? String(object.containerName)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.accountName !== undefined &&
            (obj.accountName = message.accountName);
        message.accountKey !== undefined && (obj.accountKey = message.accountKey);
        message.containerName !== undefined &&
            (obj.containerName = message.containerName);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseAzureBlobUpload();
        message.accountName = (_a = object.accountName) !== null && _a !== void 0 ? _a : "";
        message.accountKey = (_b = object.accountKey) !== null && _b !== void 0 ? _b : "";
        message.containerName = (_c = object.containerName) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseStreamOutput() {
    return { protocol: 0, urls: [] };
}
exports.StreamOutput = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.protocol !== 0) {
            writer.uint32(8).int32(message.protocol);
        }
        for (const v of message.urls) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamOutput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.protocol = reader.int32();
                    break;
                case 2:
                    message.urls.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            protocol: isSet(object.protocol)
                ? streamProtocolFromJSON(object.protocol)
                : 0,
            urls: Array.isArray(object === null || object === void 0 ? void 0 : object.urls)
                ? object.urls.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.protocol !== undefined &&
            (obj.protocol = streamProtocolToJSON(message.protocol));
        if (message.urls) {
            obj.urls = message.urls.map((e) => e);
        }
        else {
            obj.urls = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseStreamOutput();
        message.protocol = (_a = object.protocol) !== null && _a !== void 0 ? _a : 0;
        message.urls = ((_b = object.urls) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        return message;
    },
};
function createBaseEncodingOptions() {
    return {
        width: 0,
        height: 0,
        depth: 0,
        framerate: 0,
        audioCodec: 0,
        audioBitrate: 0,
        audioFrequency: 0,
        videoCodec: 0,
        videoBitrate: 0,
    };
}
exports.EncodingOptions = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.width !== 0) {
            writer.uint32(8).int32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(16).int32(message.height);
        }
        if (message.depth !== 0) {
            writer.uint32(24).int32(message.depth);
        }
        if (message.framerate !== 0) {
            writer.uint32(32).int32(message.framerate);
        }
        if (message.audioCodec !== 0) {
            writer.uint32(40).int32(message.audioCodec);
        }
        if (message.audioBitrate !== 0) {
            writer.uint32(48).int32(message.audioBitrate);
        }
        if (message.audioFrequency !== 0) {
            writer.uint32(56).int32(message.audioFrequency);
        }
        if (message.videoCodec !== 0) {
            writer.uint32(64).int32(message.videoCodec);
        }
        if (message.videoBitrate !== 0) {
            writer.uint32(72).int32(message.videoBitrate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncodingOptions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.width = reader.int32();
                    break;
                case 2:
                    message.height = reader.int32();
                    break;
                case 3:
                    message.depth = reader.int32();
                    break;
                case 4:
                    message.framerate = reader.int32();
                    break;
                case 5:
                    message.audioCodec = reader.int32();
                    break;
                case 6:
                    message.audioBitrate = reader.int32();
                    break;
                case 7:
                    message.audioFrequency = reader.int32();
                    break;
                case 8:
                    message.videoCodec = reader.int32();
                    break;
                case 9:
                    message.videoBitrate = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            width: isSet(object.width) ? Number(object.width) : 0,
            height: isSet(object.height) ? Number(object.height) : 0,
            depth: isSet(object.depth) ? Number(object.depth) : 0,
            framerate: isSet(object.framerate) ? Number(object.framerate) : 0,
            audioCodec: isSet(object.audioCodec)
                ? audioCodecFromJSON(object.audioCodec)
                : 0,
            audioBitrate: isSet(object.audioBitrate)
                ? Number(object.audioBitrate)
                : 0,
            audioFrequency: isSet(object.audioFrequency)
                ? Number(object.audioFrequency)
                : 0,
            videoCodec: isSet(object.videoCodec)
                ? videoCodecFromJSON(object.videoCodec)
                : 0,
            videoBitrate: isSet(object.videoBitrate)
                ? Number(object.videoBitrate)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.width !== undefined && (obj.width = Math.round(message.width));
        message.height !== undefined && (obj.height = Math.round(message.height));
        message.depth !== undefined && (obj.depth = Math.round(message.depth));
        message.framerate !== undefined &&
            (obj.framerate = Math.round(message.framerate));
        message.audioCodec !== undefined &&
            (obj.audioCodec = audioCodecToJSON(message.audioCodec));
        message.audioBitrate !== undefined &&
            (obj.audioBitrate = Math.round(message.audioBitrate));
        message.audioFrequency !== undefined &&
            (obj.audioFrequency = Math.round(message.audioFrequency));
        message.videoCodec !== undefined &&
            (obj.videoCodec = videoCodecToJSON(message.videoCodec));
        message.videoBitrate !== undefined &&
            (obj.videoBitrate = Math.round(message.videoBitrate));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const message = createBaseEncodingOptions();
        message.width = (_a = object.width) !== null && _a !== void 0 ? _a : 0;
        message.height = (_b = object.height) !== null && _b !== void 0 ? _b : 0;
        message.depth = (_c = object.depth) !== null && _c !== void 0 ? _c : 0;
        message.framerate = (_d = object.framerate) !== null && _d !== void 0 ? _d : 0;
        message.audioCodec = (_e = object.audioCodec) !== null && _e !== void 0 ? _e : 0;
        message.audioBitrate = (_f = object.audioBitrate) !== null && _f !== void 0 ? _f : 0;
        message.audioFrequency = (_g = object.audioFrequency) !== null && _g !== void 0 ? _g : 0;
        message.videoCodec = (_h = object.videoCodec) !== null && _h !== void 0 ? _h : 0;
        message.videoBitrate = (_j = object.videoBitrate) !== null && _j !== void 0 ? _j : 0;
        return message;
    },
};
function createBaseUpdateLayoutRequest() {
    return { egressId: "", layout: "" };
}
exports.UpdateLayoutRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.egressId !== "") {
            writer.uint32(10).string(message.egressId);
        }
        if (message.layout !== "") {
            writer.uint32(18).string(message.layout);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateLayoutRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.egressId = reader.string();
                    break;
                case 2:
                    message.layout = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            egressId: isSet(object.egressId) ? String(object.egressId) : "",
            layout: isSet(object.layout) ? String(object.layout) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.egressId !== undefined && (obj.egressId = message.egressId);
        message.layout !== undefined && (obj.layout = message.layout);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseUpdateLayoutRequest();
        message.egressId = (_a = object.egressId) !== null && _a !== void 0 ? _a : "";
        message.layout = (_b = object.layout) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseUpdateStreamRequest() {
    return { egressId: "", addOutputUrls: [], removeOutputUrls: [] };
}
exports.UpdateStreamRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.egressId !== "") {
            writer.uint32(10).string(message.egressId);
        }
        for (const v of message.addOutputUrls) {
            writer.uint32(18).string(v);
        }
        for (const v of message.removeOutputUrls) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateStreamRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.egressId = reader.string();
                    break;
                case 2:
                    message.addOutputUrls.push(reader.string());
                    break;
                case 3:
                    message.removeOutputUrls.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            egressId: isSet(object.egressId) ? String(object.egressId) : "",
            addOutputUrls: Array.isArray(object === null || object === void 0 ? void 0 : object.addOutputUrls)
                ? object.addOutputUrls.map((e) => String(e))
                : [],
            removeOutputUrls: Array.isArray(object === null || object === void 0 ? void 0 : object.removeOutputUrls)
                ? object.removeOutputUrls.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.egressId !== undefined && (obj.egressId = message.egressId);
        if (message.addOutputUrls) {
            obj.addOutputUrls = message.addOutputUrls.map((e) => e);
        }
        else {
            obj.addOutputUrls = [];
        }
        if (message.removeOutputUrls) {
            obj.removeOutputUrls = message.removeOutputUrls.map((e) => e);
        }
        else {
            obj.removeOutputUrls = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseUpdateStreamRequest();
        message.egressId = (_a = object.egressId) !== null && _a !== void 0 ? _a : "";
        message.addOutputUrls = ((_b = object.addOutputUrls) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.removeOutputUrls = ((_c = object.removeOutputUrls) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        return message;
    },
};
function createBaseListEgressRequest() {
    return { roomName: "" };
}
exports.ListEgressRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.roomName !== "") {
            writer.uint32(10).string(message.roomName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListEgressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.roomName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            roomName: isSet(object.roomName) ? String(object.roomName) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.roomName !== undefined && (obj.roomName = message.roomName);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseListEgressRequest();
        message.roomName = (_a = object.roomName) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseListEgressResponse() {
    return { items: [] };
}
exports.ListEgressResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.items) {
            exports.EgressInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListEgressResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.items.push(exports.EgressInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            items: Array.isArray(object === null || object === void 0 ? void 0 : object.items)
                ? object.items.map((e) => exports.EgressInfo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.items) {
            obj.items = message.items.map((e) => e ? exports.EgressInfo.toJSON(e) : undefined);
        }
        else {
            obj.items = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseListEgressResponse();
        message.items = ((_a = object.items) === null || _a === void 0 ? void 0 : _a.map((e) => exports.EgressInfo.fromPartial(e))) || [];
        return message;
    },
};
function createBaseStopEgressRequest() {
    return { egressId: "" };
}
exports.StopEgressRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.egressId !== "") {
            writer.uint32(10).string(message.egressId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStopEgressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.egressId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            egressId: isSet(object.egressId) ? String(object.egressId) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.egressId !== undefined && (obj.egressId = message.egressId);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseStopEgressRequest();
        message.egressId = (_a = object.egressId) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseEgressInfo() {
    return {
        egressId: "",
        roomId: "",
        status: 0,
        webComposite: undefined,
        trackComposite: undefined,
        track: undefined,
        stream: undefined,
        file: undefined,
        error: "",
    };
}
exports.EgressInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.egressId !== "") {
            writer.uint32(10).string(message.egressId);
        }
        if (message.roomId !== "") {
            writer.uint32(18).string(message.roomId);
        }
        if (message.status !== 0) {
            writer.uint32(24).int32(message.status);
        }
        if (message.webComposite !== undefined) {
            exports.WebCompositeEgressRequest.encode(message.webComposite, writer.uint32(34).fork()).ldelim();
        }
        if (message.trackComposite !== undefined) {
            exports.TrackCompositeEgressRequest.encode(message.trackComposite, writer.uint32(42).fork()).ldelim();
        }
        if (message.track !== undefined) {
            exports.TrackEgressRequest.encode(message.track, writer.uint32(50).fork()).ldelim();
        }
        if (message.stream !== undefined) {
            exports.StreamInfoList.encode(message.stream, writer.uint32(58).fork()).ldelim();
        }
        if (message.file !== undefined) {
            exports.FileInfo.encode(message.file, writer.uint32(66).fork()).ldelim();
        }
        if (message.error !== "") {
            writer.uint32(74).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEgressInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.egressId = reader.string();
                    break;
                case 2:
                    message.roomId = reader.string();
                    break;
                case 3:
                    message.status = reader.int32();
                    break;
                case 4:
                    message.webComposite = exports.WebCompositeEgressRequest.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.trackComposite = exports.TrackCompositeEgressRequest.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.track = exports.TrackEgressRequest.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.stream = exports.StreamInfoList.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.file = exports.FileInfo.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.error = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            egressId: isSet(object.egressId) ? String(object.egressId) : "",
            roomId: isSet(object.roomId) ? String(object.roomId) : "",
            status: isSet(object.status) ? egressStatusFromJSON(object.status) : 0,
            webComposite: isSet(object.webComposite)
                ? exports.WebCompositeEgressRequest.fromJSON(object.webComposite)
                : undefined,
            trackComposite: isSet(object.trackComposite)
                ? exports.TrackCompositeEgressRequest.fromJSON(object.trackComposite)
                : undefined,
            track: isSet(object.track)
                ? exports.TrackEgressRequest.fromJSON(object.track)
                : undefined,
            stream: isSet(object.stream)
                ? exports.StreamInfoList.fromJSON(object.stream)
                : undefined,
            file: isSet(object.file) ? exports.FileInfo.fromJSON(object.file) : undefined,
            error: isSet(object.error) ? String(object.error) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.egressId !== undefined && (obj.egressId = message.egressId);
        message.roomId !== undefined && (obj.roomId = message.roomId);
        message.status !== undefined &&
            (obj.status = egressStatusToJSON(message.status));
        message.webComposite !== undefined &&
            (obj.webComposite = message.webComposite
                ? exports.WebCompositeEgressRequest.toJSON(message.webComposite)
                : undefined);
        message.trackComposite !== undefined &&
            (obj.trackComposite = message.trackComposite
                ? exports.TrackCompositeEgressRequest.toJSON(message.trackComposite)
                : undefined);
        message.track !== undefined &&
            (obj.track = message.track
                ? exports.TrackEgressRequest.toJSON(message.track)
                : undefined);
        message.stream !== undefined &&
            (obj.stream = message.stream
                ? exports.StreamInfoList.toJSON(message.stream)
                : undefined);
        message.file !== undefined &&
            (obj.file = message.file ? exports.FileInfo.toJSON(message.file) : undefined);
        message.error !== undefined && (obj.error = message.error);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseEgressInfo();
        message.egressId = (_a = object.egressId) !== null && _a !== void 0 ? _a : "";
        message.roomId = (_b = object.roomId) !== null && _b !== void 0 ? _b : "";
        message.status = (_c = object.status) !== null && _c !== void 0 ? _c : 0;
        message.webComposite =
            object.webComposite !== undefined && object.webComposite !== null
                ? exports.WebCompositeEgressRequest.fromPartial(object.webComposite)
                : undefined;
        message.trackComposite =
            object.trackComposite !== undefined && object.trackComposite !== null
                ? exports.TrackCompositeEgressRequest.fromPartial(object.trackComposite)
                : undefined;
        message.track =
            object.track !== undefined && object.track !== null
                ? exports.TrackEgressRequest.fromPartial(object.track)
                : undefined;
        message.stream =
            object.stream !== undefined && object.stream !== null
                ? exports.StreamInfoList.fromPartial(object.stream)
                : undefined;
        message.file =
            object.file !== undefined && object.file !== null
                ? exports.FileInfo.fromPartial(object.file)
                : undefined;
        message.error = (_d = object.error) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseStreamInfoList() {
    return { info: [] };
}
exports.StreamInfoList = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.info) {
            exports.StreamInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamInfoList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.info.push(exports.StreamInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            info: Array.isArray(object === null || object === void 0 ? void 0 : object.info)
                ? object.info.map((e) => exports.StreamInfo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.info) {
            obj.info = message.info.map((e) => e ? exports.StreamInfo.toJSON(e) : undefined);
        }
        else {
            obj.info = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseStreamInfoList();
        message.info = ((_a = object.info) === null || _a === void 0 ? void 0 : _a.map((e) => exports.StreamInfo.fromPartial(e))) || [];
        return message;
    },
};
function createBaseStreamInfo() {
    return { url: "", startedAt: 0, endedAt: 0 };
}
exports.StreamInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.url !== "") {
            writer.uint32(10).string(message.url);
        }
        if (message.startedAt !== 0) {
            writer.uint32(16).int64(message.startedAt);
        }
        if (message.endedAt !== 0) {
            writer.uint32(24).int64(message.endedAt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStreamInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.url = reader.string();
                    break;
                case 2:
                    message.startedAt = longToNumber(reader.int64());
                    break;
                case 3:
                    message.endedAt = longToNumber(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            url: isSet(object.url) ? String(object.url) : "",
            startedAt: isSet(object.startedAt) ? Number(object.startedAt) : 0,
            endedAt: isSet(object.endedAt) ? Number(object.endedAt) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.url !== undefined && (obj.url = message.url);
        message.startedAt !== undefined &&
            (obj.startedAt = Math.round(message.startedAt));
        message.endedAt !== undefined &&
            (obj.endedAt = Math.round(message.endedAt));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseStreamInfo();
        message.url = (_a = object.url) !== null && _a !== void 0 ? _a : "";
        message.startedAt = (_b = object.startedAt) !== null && _b !== void 0 ? _b : 0;
        message.endedAt = (_c = object.endedAt) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseFileInfo() {
    return { filename: "", startedAt: 0, endedAt: 0, size: 0, location: "" };
}
exports.FileInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.filename !== "") {
            writer.uint32(10).string(message.filename);
        }
        if (message.startedAt !== 0) {
            writer.uint32(16).int64(message.startedAt);
        }
        if (message.endedAt !== 0) {
            writer.uint32(24).int64(message.endedAt);
        }
        if (message.size !== 0) {
            writer.uint32(32).int64(message.size);
        }
        if (message.location !== "") {
            writer.uint32(42).string(message.location);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFileInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.filename = reader.string();
                    break;
                case 2:
                    message.startedAt = longToNumber(reader.int64());
                    break;
                case 3:
                    message.endedAt = longToNumber(reader.int64());
                    break;
                case 4:
                    message.size = longToNumber(reader.int64());
                    break;
                case 5:
                    message.location = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            filename: isSet(object.filename) ? String(object.filename) : "",
            startedAt: isSet(object.startedAt) ? Number(object.startedAt) : 0,
            endedAt: isSet(object.endedAt) ? Number(object.endedAt) : 0,
            size: isSet(object.size) ? Number(object.size) : 0,
            location: isSet(object.location) ? String(object.location) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.filename !== undefined && (obj.filename = message.filename);
        message.startedAt !== undefined &&
            (obj.startedAt = Math.round(message.startedAt));
        message.endedAt !== undefined &&
            (obj.endedAt = Math.round(message.endedAt));
        message.size !== undefined && (obj.size = Math.round(message.size));
        message.location !== undefined && (obj.location = message.location);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseFileInfo();
        message.filename = (_a = object.filename) !== null && _a !== void 0 ? _a : "";
        message.startedAt = (_b = object.startedAt) !== null && _b !== void 0 ? _b : 0;
        message.endedAt = (_c = object.endedAt) !== null && _c !== void 0 ? _c : 0;
        message.size = (_d = object.size) !== null && _d !== void 0 ? _d : 0;
        message.location = (_e = object.location) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=livekit_egress.js.map