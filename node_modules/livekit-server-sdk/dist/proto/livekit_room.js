"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateRoomMetadataRequest = exports.SendDataResponse = exports.SendDataRequest = exports.UpdateSubscriptionsResponse = exports.UpdateSubscriptionsRequest = exports.UpdateParticipantRequest = exports.MuteRoomTrackResponse = exports.MuteRoomTrackRequest = exports.RemoveParticipantResponse = exports.RoomParticipantIdentity = exports.ListParticipantsResponse = exports.ListParticipantsRequest = exports.DeleteRoomResponse = exports.DeleteRoomRequest = exports.ListRoomsResponse = exports.ListRoomsRequest = exports.CreateRoomRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const _m0 = __importStar(require("protobufjs/minimal"));
const livekit_models_1 = require("./livekit_models");
exports.protobufPackage = "livekit";
function createBaseCreateRoomRequest() {
    return {
        name: "",
        emptyTimeout: 0,
        maxParticipants: 0,
        nodeId: "",
        metadata: "",
    };
}
exports.CreateRoomRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.emptyTimeout !== 0) {
            writer.uint32(16).uint32(message.emptyTimeout);
        }
        if (message.maxParticipants !== 0) {
            writer.uint32(24).uint32(message.maxParticipants);
        }
        if (message.nodeId !== "") {
            writer.uint32(34).string(message.nodeId);
        }
        if (message.metadata !== "") {
            writer.uint32(42).string(message.metadata);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateRoomRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.emptyTimeout = reader.uint32();
                    break;
                case 3:
                    message.maxParticipants = reader.uint32();
                    break;
                case 4:
                    message.nodeId = reader.string();
                    break;
                case 5:
                    message.metadata = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? String(object.name) : "",
            emptyTimeout: isSet(object.emptyTimeout)
                ? Number(object.emptyTimeout)
                : 0,
            maxParticipants: isSet(object.maxParticipants)
                ? Number(object.maxParticipants)
                : 0,
            nodeId: isSet(object.nodeId) ? String(object.nodeId) : "",
            metadata: isSet(object.metadata) ? String(object.metadata) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.emptyTimeout !== undefined &&
            (obj.emptyTimeout = Math.round(message.emptyTimeout));
        message.maxParticipants !== undefined &&
            (obj.maxParticipants = Math.round(message.maxParticipants));
        message.nodeId !== undefined && (obj.nodeId = message.nodeId);
        message.metadata !== undefined && (obj.metadata = message.metadata);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseCreateRoomRequest();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.emptyTimeout = (_b = object.emptyTimeout) !== null && _b !== void 0 ? _b : 0;
        message.maxParticipants = (_c = object.maxParticipants) !== null && _c !== void 0 ? _c : 0;
        message.nodeId = (_d = object.nodeId) !== null && _d !== void 0 ? _d : "";
        message.metadata = (_e = object.metadata) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseListRoomsRequest() {
    return { names: [] };
}
exports.ListRoomsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.names) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListRoomsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.names.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            names: Array.isArray(object === null || object === void 0 ? void 0 : object.names)
                ? object.names.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.names) {
            obj.names = message.names.map((e) => e);
        }
        else {
            obj.names = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseListRoomsRequest();
        message.names = ((_a = object.names) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];
        return message;
    },
};
function createBaseListRoomsResponse() {
    return { rooms: [] };
}
exports.ListRoomsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.rooms) {
            livekit_models_1.Room.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListRoomsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.rooms.push(livekit_models_1.Room.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            rooms: Array.isArray(object === null || object === void 0 ? void 0 : object.rooms)
                ? object.rooms.map((e) => livekit_models_1.Room.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rooms) {
            obj.rooms = message.rooms.map((e) => (e ? livekit_models_1.Room.toJSON(e) : undefined));
        }
        else {
            obj.rooms = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseListRoomsResponse();
        message.rooms = ((_a = object.rooms) === null || _a === void 0 ? void 0 : _a.map((e) => livekit_models_1.Room.fromPartial(e))) || [];
        return message;
    },
};
function createBaseDeleteRoomRequest() {
    return { room: "" };
}
exports.DeleteRoomRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteRoomRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            room: isSet(object.room) ? String(object.room) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseDeleteRoomRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseDeleteRoomResponse() {
    return {};
}
exports.DeleteRoomResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeleteRoomResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseDeleteRoomResponse();
        return message;
    },
};
function createBaseListParticipantsRequest() {
    return { room: "" };
}
exports.ListParticipantsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListParticipantsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            room: isSet(object.room) ? String(object.room) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseListParticipantsRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseListParticipantsResponse() {
    return { participants: [] };
}
exports.ListParticipantsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.participants) {
            livekit_models_1.ParticipantInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListParticipantsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.participants.push(livekit_models_1.ParticipantInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            participants: Array.isArray(object === null || object === void 0 ? void 0 : object.participants)
                ? object.participants.map((e) => livekit_models_1.ParticipantInfo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.participants) {
            obj.participants = message.participants.map((e) => e ? livekit_models_1.ParticipantInfo.toJSON(e) : undefined);
        }
        else {
            obj.participants = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseListParticipantsResponse();
        message.participants =
            ((_a = object.participants) === null || _a === void 0 ? void 0 : _a.map((e) => livekit_models_1.ParticipantInfo.fromPartial(e))) || [];
        return message;
    },
};
function createBaseRoomParticipantIdentity() {
    return { room: "", identity: "" };
}
exports.RoomParticipantIdentity = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        if (message.identity !== "") {
            writer.uint32(18).string(message.identity);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRoomParticipantIdentity();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                case 2:
                    message.identity = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            room: isSet(object.room) ? String(object.room) : "",
            identity: isSet(object.identity) ? String(object.identity) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        message.identity !== undefined && (obj.identity = message.identity);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseRoomParticipantIdentity();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseRemoveParticipantResponse() {
    return {};
}
exports.RemoveParticipantResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemoveParticipantResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseRemoveParticipantResponse();
        return message;
    },
};
function createBaseMuteRoomTrackRequest() {
    return { room: "", identity: "", trackSid: "", muted: false };
}
exports.MuteRoomTrackRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        if (message.identity !== "") {
            writer.uint32(18).string(message.identity);
        }
        if (message.trackSid !== "") {
            writer.uint32(26).string(message.trackSid);
        }
        if (message.muted === true) {
            writer.uint32(32).bool(message.muted);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMuteRoomTrackRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                case 2:
                    message.identity = reader.string();
                    break;
                case 3:
                    message.trackSid = reader.string();
                    break;
                case 4:
                    message.muted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            room: isSet(object.room) ? String(object.room) : "",
            identity: isSet(object.identity) ? String(object.identity) : "",
            trackSid: isSet(object.trackSid) ? String(object.trackSid) : "",
            muted: isSet(object.muted) ? Boolean(object.muted) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        message.identity !== undefined && (obj.identity = message.identity);
        message.trackSid !== undefined && (obj.trackSid = message.trackSid);
        message.muted !== undefined && (obj.muted = message.muted);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMuteRoomTrackRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        message.trackSid = (_c = object.trackSid) !== null && _c !== void 0 ? _c : "";
        message.muted = (_d = object.muted) !== null && _d !== void 0 ? _d : false;
        return message;
    },
};
function createBaseMuteRoomTrackResponse() {
    return { track: undefined };
}
exports.MuteRoomTrackResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.track !== undefined) {
            livekit_models_1.TrackInfo.encode(message.track, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMuteRoomTrackResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.track = livekit_models_1.TrackInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            track: isSet(object.track) ? livekit_models_1.TrackInfo.fromJSON(object.track) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.track !== undefined &&
            (obj.track = message.track ? livekit_models_1.TrackInfo.toJSON(message.track) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseMuteRoomTrackResponse();
        message.track =
            object.track !== undefined && object.track !== null
                ? livekit_models_1.TrackInfo.fromPartial(object.track)
                : undefined;
        return message;
    },
};
function createBaseUpdateParticipantRequest() {
    return { room: "", identity: "", metadata: "", permission: undefined };
}
exports.UpdateParticipantRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        if (message.identity !== "") {
            writer.uint32(18).string(message.identity);
        }
        if (message.metadata !== "") {
            writer.uint32(26).string(message.metadata);
        }
        if (message.permission !== undefined) {
            livekit_models_1.ParticipantPermission.encode(message.permission, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateParticipantRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                case 2:
                    message.identity = reader.string();
                    break;
                case 3:
                    message.metadata = reader.string();
                    break;
                case 4:
                    message.permission = livekit_models_1.ParticipantPermission.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            room: isSet(object.room) ? String(object.room) : "",
            identity: isSet(object.identity) ? String(object.identity) : "",
            metadata: isSet(object.metadata) ? String(object.metadata) : "",
            permission: isSet(object.permission)
                ? livekit_models_1.ParticipantPermission.fromJSON(object.permission)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        message.identity !== undefined && (obj.identity = message.identity);
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.permission !== undefined &&
            (obj.permission = message.permission
                ? livekit_models_1.ParticipantPermission.toJSON(message.permission)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseUpdateParticipantRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        message.metadata = (_c = object.metadata) !== null && _c !== void 0 ? _c : "";
        message.permission =
            object.permission !== undefined && object.permission !== null
                ? livekit_models_1.ParticipantPermission.fromPartial(object.permission)
                : undefined;
        return message;
    },
};
function createBaseUpdateSubscriptionsRequest() {
    return {
        room: "",
        identity: "",
        trackSids: [],
        subscribe: false,
        participantTracks: [],
    };
}
exports.UpdateSubscriptionsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        if (message.identity !== "") {
            writer.uint32(18).string(message.identity);
        }
        for (const v of message.trackSids) {
            writer.uint32(26).string(v);
        }
        if (message.subscribe === true) {
            writer.uint32(32).bool(message.subscribe);
        }
        for (const v of message.participantTracks) {
            livekit_models_1.ParticipantTracks.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateSubscriptionsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                case 2:
                    message.identity = reader.string();
                    break;
                case 3:
                    message.trackSids.push(reader.string());
                    break;
                case 4:
                    message.subscribe = reader.bool();
                    break;
                case 5:
                    message.participantTracks.push(livekit_models_1.ParticipantTracks.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            room: isSet(object.room) ? String(object.room) : "",
            identity: isSet(object.identity) ? String(object.identity) : "",
            trackSids: Array.isArray(object === null || object === void 0 ? void 0 : object.trackSids)
                ? object.trackSids.map((e) => String(e))
                : [],
            subscribe: isSet(object.subscribe) ? Boolean(object.subscribe) : false,
            participantTracks: Array.isArray(object === null || object === void 0 ? void 0 : object.participantTracks)
                ? object.participantTracks.map((e) => livekit_models_1.ParticipantTracks.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        message.identity !== undefined && (obj.identity = message.identity);
        if (message.trackSids) {
            obj.trackSids = message.trackSids.map((e) => e);
        }
        else {
            obj.trackSids = [];
        }
        message.subscribe !== undefined && (obj.subscribe = message.subscribe);
        if (message.participantTracks) {
            obj.participantTracks = message.participantTracks.map((e) => e ? livekit_models_1.ParticipantTracks.toJSON(e) : undefined);
        }
        else {
            obj.participantTracks = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseUpdateSubscriptionsRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : "";
        message.trackSids = ((_c = object.trackSids) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];
        message.subscribe = (_d = object.subscribe) !== null && _d !== void 0 ? _d : false;
        message.participantTracks =
            ((_e = object.participantTracks) === null || _e === void 0 ? void 0 : _e.map((e) => livekit_models_1.ParticipantTracks.fromPartial(e))) ||
                [];
        return message;
    },
};
function createBaseUpdateSubscriptionsResponse() {
    return {};
}
exports.UpdateSubscriptionsResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateSubscriptionsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseUpdateSubscriptionsResponse();
        return message;
    },
};
function createBaseSendDataRequest() {
    return { room: "", data: new Uint8Array(), kind: 0, destinationSids: [] };
}
exports.SendDataRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        if (message.data.length !== 0) {
            writer.uint32(18).bytes(message.data);
        }
        if (message.kind !== 0) {
            writer.uint32(24).int32(message.kind);
        }
        for (const v of message.destinationSids) {
            writer.uint32(34).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendDataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.kind = reader.int32();
                    break;
                case 4:
                    message.destinationSids.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            room: isSet(object.room) ? String(object.room) : "",
            data: isSet(object.data)
                ? bytesFromBase64(object.data)
                : new Uint8Array(),
            kind: isSet(object.kind) ? livekit_models_1.dataPacket_KindFromJSON(object.kind) : 0,
            destinationSids: Array.isArray(object === null || object === void 0 ? void 0 : object.destinationSids)
                ? object.destinationSids.map((e) => String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        message.data !== undefined &&
            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
        message.kind !== undefined &&
            (obj.kind = livekit_models_1.dataPacket_KindToJSON(message.kind));
        if (message.destinationSids) {
            obj.destinationSids = message.destinationSids.map((e) => e);
        }
        else {
            obj.destinationSids = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseSendDataRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.kind = (_c = object.kind) !== null && _c !== void 0 ? _c : 0;
        message.destinationSids = ((_d = object.destinationSids) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];
        return message;
    },
};
function createBaseSendDataResponse() {
    return {};
}
exports.SendDataResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendDataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = createBaseSendDataResponse();
        return message;
    },
};
function createBaseUpdateRoomMetadataRequest() {
    return { room: "", metadata: "" };
}
exports.UpdateRoomMetadataRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        if (message.metadata !== "") {
            writer.uint32(18).string(message.metadata);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateRoomMetadataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                case 2:
                    message.metadata = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            room: isSet(object.room) ? String(object.room) : "",
            metadata: isSet(object.metadata) ? String(object.metadata) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        message.metadata !== undefined && (obj.metadata = message.metadata);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseUpdateRoomMetadataRequest();
        message.room = (_a = object.room) !== null && _a !== void 0 ? _a : "";
        message.metadata = (_b = object.metadata) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
if (_m0.util.Long !== long_1.default) {
    _m0.util.Long = long_1.default;
    _m0.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=livekit_room.js.map